//@@viewOn:imports
import UU5 from "uu5g04";
import "uu5g04-bricks"
import { createVisualComponent, useRef } from "uu5g04-hooks";
import Config from "./config/config";
import "uu5chartg01";
import DataProvider from "./data-provider";
//@@viewOff:imports

const Graph = createVisualComponent({
    //@@viewOn:statics

    displayName: Config.TAG + "Graph",
    //@@viewOff:statics
    //@@viewOn:propTypes
    propTypes: {
      data: UU5.PropTypes.shape({}),
      baseUri: UU5.PropTypes.string,
      graphType: UU5.PropTypes.oneOf(["last 24h", "week", "month"])
    },
    //@@viewOff:propTypes

    //@@viewOn:defaultProps
    defaultProps: {
      graphType: 'week'
    },
    //@@viewOff:defaultProps

    render({ data: gateway, baseUri, graphType }) {
        //@@viewOn:interface
        //@@viewOn:handlers
        const handlerMapRef = useRef();
        const dataRef = useRef();
       
        /**
         * @param {string} graphType one of ["last 24h", "week", "month"]
         * @returns {string} a string in simplified extended ISO format
         */
        const getStartTime = (graphType) => {
            switch(graphType) {
                case "month": 
                    let d = new Date; 
                    d.setMonth(d.getMonth() - 1);
                    return d.toISOString();
                case "week": 
                    return new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString() 
                case "last 24h":
                default:
                    return new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString()
            }
        }
        const startTime = getStartTime(graphType);
        /**
         * trigger a load on graphType change if initial load has been already made 
         */
        if(handlerMapRef.current) handlerMapRef.current.load({baseUri, gatewayName: gateway.gatewayName, startTime, graphType });

        function renderLoad() {
            return <UU5.Bricks.Loading />;
          }
      
        function renderReady(data, isLoading) {
            if(!data || !data[0]) return 'Sorry, no data for specified period available!';

            /**
             * @param {object} dateObj - _id field from server response (generated by mongodb group aggregation)
             * @returns {string}
             */
            const formatLabel = (dateObj) => {
                if(!dateObj.year||!dateObj.month||!dateObj.day) return 'Unknown';
                return new Date(dateObj.year + "-" + dateObj.month + "-" + dateObj.day).toLocaleString('default', { weekday: 'short', day: '2-digit', month: 'short' });
            }

            /**
             * @param {number} metric 
             * @returns {number} Rounded to hundreds
             */
            const roundMetric = (metric) => metric ? ~~(metric*100)/100 : undefined;

            const graphData = data.map(metric => ({
                label: formatLabel(metric._id),
                temperature: roundMetric(metric.temperature),
                humidity: roundMetric(metric.humidity),
            }));

            const graphSeries = [{
                valueKey: "temperature",
                name: "Temperature",
                colorSchema: "red",
                chartType: "monotone"
              },
              {
                valueKey: "humidity",
                name: "Humidity",
                colorSchema: "blue",
                chartType: "monotone"
              }]
            return (
              <UU5.Common.Fragment>
                {/* <UU5.Bricks.Text>Latest temperature: { roundMetric(data[data.length-1].temperature) || 'unknown'} &#8451;</UU5.Bricks.Text>
                <UU5.Bricks.Text>Latest humidity: { roundMetric(data[data.length-1].humidity) || 'unknown'}% </UU5.Bricks.Text> */}
                {isLoading&&<UU5.Bricks.Loading className='loader-custom' />}
                <UU5.SimpleChart.LineChart data={graphData} series={graphSeries} />
              </UU5.Common.Fragment>
            )
          }
      
        function renderError(errorData) {
            return <UU5.Bricks.Error 
            content={errorData.reason||'Error happened!'}
            error={errorData.error}
            errorData={errorData.data} />
          }
        
        //@@viewOff:handlers
        //@@viewOn:render
        return (
        <DataProvider baseUri={baseUri} gatewayName={gateway.gatewayName} startTime={startTime} graphType={graphType} >
            {({ state, data, errorData, handlerMap }) => {
          switch (state) {
            case "pending":
            case "pendingNoData":
              if(dataRef.current) return renderReady(dataRef.current, true);
              return renderLoad();
            case "error":
            case "errorNoData":
              errorData.reason = `Error happened! Most likely data for gateway with ${data.id} id couldn't be fetched.`
              return renderError(errorData);
            case "itemPending":
            case "ready":
            case "readyNoData":
            default:
              if (!handlerMapRef.current) handlerMapRef.current = handlerMap;
              dataRef.current = data;
              return renderReady(dataRef.current, false);
          }
        }}
        </DataProvider>
        );
        //@@viewOff:render
    },
});

export default Graph;
